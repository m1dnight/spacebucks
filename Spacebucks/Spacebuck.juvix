module Spacebucks.Spacebuck;

import Stdlib.Prelude open;
import Applib open;
import Anoma.Encode open;
import Stdlib.Debug.Trace open;
import Anoma.Identity.External open;
import Anoma.Identity.Internal open;
import BaseLayer.ResourceMachine open;

-- ----------------------------------------------------------------------------
--  Helpers

-- decode an atom into another type.
decode-atom {T} (atom : AnomaAtom) : T :=
  builtinAnomaDecode (AnomaAtom.toNat atom);

encode-atom {T} (value : T) : AnomaAtom :=
  AnomaAtom.fromNat (builtinAnomaEncode value);

-- Returns the owner of a spacebuck resource.
-- The owner is defined by their public key.
spacebuck-owner (resource : Resource) : ExternalIdentity :=
  let
    value := Resource.value resource;
    spacebuck-value : SpacebuckValue := decode-atom value;
    owner : ExternalIdentity := SpacebuckValue.owner spacebuck-value;
  in owner;

-- ----------------------------------------------------------------------------
--  Logic function

-- validate an ephemeral consumed resource
validate-ephemeral-consumed-resource (args : Logic.Args) : Bool :=
  let
    x := trace "validate-ephemeral-consumed-resource" >-> 1;
    owner : ExternalIdentity := spacebuck-owner (Logic.Args.self args);
  in true;

-- validate an ephemeral created resource
validate-ephemeral-created-resource (args : Logic.Args) : Bool :=
  let
    x := trace "validate-ephemeral-created-resource" >-> 1;
    owner : ExternalIdentity := spacebuck-owner (Logic.Args.self args);
  in true;

-- validate a consumed resource
validate-non-ephemeral-consumed-resource (args : Logic.Args) : Bool :=
  let
    x := trace "validate-non-ephemeral-consumed-resource" >-> 1;
    owner : ExternalIdentity := spacebuck-owner (Logic.Args.self args);
  in true;

-- validate a created resource
validate-non-ephemeral-created-resource (args : Logic.Args) : Bool :=
  let
    x := trace "validate-non-ephemeral-created-resource" >-> 1;
    owner : ExternalIdentity := spacebuck-owner (Logic.Args.self args);
  in true;

logicFunction (args : Logic.Args) : Bool :=
  -- >-> trace "isConsumed"
  -- >-> trace (Logic.Args.isConsumed args)
  -- >-> trace (Resource.nonce (Logic.Args.self args))
  -- >-> trace (listMap Resource.nonce (Logic.Args.consumed args))
  -- >-> trace (listMap Resource.nonce (Logic.Args.created args))
  -- >-> trace (length (Logic.Args.created args))
  -- >-> trace (Logic.Args.appData args)
  -- >-> trace (Resource.ephemeral (Logic.Args.self args))
  -- >-> trace "ending"

  let
    value := "here";
    appdata := Logic.Args.appData args;
    selfTag := RawTag.fromTag (Logic.Args.selfTag args);
  in trace value >-> trace selfTag >-> true;
-- in if
--   | is-ephemeral && is-created := validate-ephemeral-created-resource args
--   | is-ephemeral := validate-ephemeral-consumed-resource args
--   | is-created := validate-non-ephemeral-created-resource args
--   | else := validate-non-ephemeral-consumed-resource args;

-- ----------------------------------------------------------------------------
--  Create a transaction to mint some spacebucks.

create-spacebucks-transaction
  {M : Type -> Type}
  {{Monad M}}
  {{Tx M}}
  (logic : Logic)
  (creator : Identity)
  : M Transaction :=
  do {
    ctx <- getTxContext;
    nonce1 <- genRandomNonce;
    nonce2 <- genRandomNonce;
    let
      label := Label.mk 0;
      quantity := 10;
      nonce := Nonce.toRaw nonce1;
      newResource := make-spacebuck logic creator label quantity nonce;
      action : Action :=
        Action.mk@{
          commitments := [];
          nullifiers := [];
          resourceLogicProofs := AnomaMap.fromList [];
          complianceUnits := AnomaSet.fromList [];
          appData := AppData.empty;
        };
    in
    mkTransactionNoPublicData@{
      consumed :=
        [newResource@Resource{ephemeral := true; nonce := Nonce.toRaw nonce2}];
      created := [newResource];
    };
  };

-- ----------------------------------------------------------------------------
--  Value for a Spacebuck
--
-- The value of a spacebuck is the meta-data associated with it.
-- For each user, we add the owner as the value.

type SpacebuckValue :=
  mkSpacebuckValue@{
    owner : ExternalIdentity;
  };

make-spacebuck-value (creator : ExternalIdentity) : SpacebuckValue :=
  SpacebuckValue.mkSpacebuckValue@{
    owner := creator;
  };

-- ----------------------------------------------------------------------------
--  Spacebuck definition

-- resourceLogic: The logic of a resource defines constraints on how it can be
-- consumed or created.
--
-- creator: The keypair of the user who creates this resource.
--
-- label: The label is the unique identifier of a resource. It differentiates
-- between Bob's spacebucks and Alice's spacebucks.
--
-- value: the value of the resource. This is sort of a meta data field where we can put in anything we want.
--
-- quantity: quantity of the resource, e.g., how many spacebucks.
--
-- nonce: the nonce of the resource. TODO

nullifiers-for-consumed (resources : List Resource) : List Nullifier :=
  map Resource.Transparent.nullifier resources;

commitments-for-created (resources : List Resource) : List Commitment :=
  map (rawCommitment >> Commitment.fromNat) resources;

create-signature (message : String) (private-key : InternalIdentity) : Signature :=
  let
    key-bytes : ByteArray := InternalIdentity.toByteArray private-key;
    signature : ByteArray := SystemBuiltins.anomaSignDetached message key-bytes;
  in
    Signature.mk@{ unSignature := signature };

make-spacebuck
  (resource-logic : Logic)
  (creator : Identity)
  (label : Label)
  (quantity : Nat)
  (nonce : Nonce.Raw)
  : Resource :=
  let
    creator-public : ExternalIdentity := Identity.external creator;
    spacebuck-value : SpacebuckValue := make-spacebuck-value creator-public;
    value : AnomaAtom := AnomaAtom.fromNat (builtinAnomaEncode spacebuck-value);
  in trace "spacebuck-value"
    >-> trace "value going in"
    >-> trace value
    >-> Resource.mk@{
          logic := Encoded.encode resource-logic;
          label := make-spacebuck-label;
          value := value;
          quantity := quantity;
          ephemeral := false;
          nonce := nonce;
          nullifierKeyCommitment := 0;
          unusedRandSeed := 0;
        };

-- ----------------------------------------------------------------------------
--  Spacebuck Label
--
-- The label of a spacebuck is just the string "Spacebuck".

make-spacebuck-label : Label := Label.mk (builtinAnomaEncode "spacebucks");

-- ----------------------------------------------------------------------------
--  Main function

-- The label of a spacebuck is what uniquely identifies it. If Bob makes a
-- spacebuck, it's uniquely identified by the pair
-- (bob_public_key, "spacebuck").
main
  (logic : Logic)
  (publicKey : ByteArray)
  (privateKey : ByteArray)
  (latest-root : CommitmentRoot)
  : TransactionRequest :=
  let
    -- parse the public and private key from the arguments and create the caller
    public-key : ExternalIdentity := ExternalIdentity.fromByteArray publicKey;
    private-key : InternalIdentity := InternalIdentity.fromByteArray privateKey;
    creator : Identity :=
      Identity.mk@{
        internal := private-key;
        external := public-key;
      };
    -- create the transaction context which holds the caller and the current root
    context : TxContext :=
      TxContext.mk@{
        caller := creator;
        currentRoot := latest-root;
      };
  in TransactionRequest.build
    0
    context
    (create-spacebucks-transaction logic creator);

-- Questions
-- =========
--  What is a nonce for a resource? What purpose does it serve?

-- Create a transaction to transfer resource R from A to B
-- =======================================================

-- A submits a transaction with parameters [R, A_public_key, A_private_key, B_public_key]

-- In the transaction function:

--   - create a resource R' that has B as the owner
--   - put actions in the transaction that contain the signature of some message M, signed with A_public_key, and A_private_key

-- The resource logic then verifies this transaction by:
--   - the resource logic can verify by using:
--     - the public key in the resource
--     - the message that was originally signed
--     - the signature put into the actions in the transaction function
