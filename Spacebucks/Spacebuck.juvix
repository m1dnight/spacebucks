module Spacebucks.Spacebuck;

import Stdlib.Prelude open;
import Applib open;
import Anoma.Encode open;
import Stdlib.Debug as Debug;

-- ### Module, imports ###


logicFunction  (args : Logic.Args) : Bool :=
Debug.trace args >-> true;

mkSpacebuck
  (nonce : Nonce)
  (logic : Logic)
  (message : String)
  {ephemeral : Bool := false}
  : Resource :=
  Resource.mk@{
    logic := Encoded.encode logic;
    label := Label.fromNat (builtinAnomaEncode message);
    value := AnomaAtom.fromNat 0;
    quantity := 1;
    ephemeral;
    nonce := Nonce.toRaw nonce;
    nullifierKeyCommitment := AnomaAtom.fromNat 0;
    unusedRandSeed := 0;
  };

spacebuckTransaction
  {M : Type -> Type}
  -- polymorphic function with type parameter M
  {{Monad M}}
  -- additional information for type parameter M
  {{Tx M}}
  -- random number generator needs side effects / Monad
  (logic : Logic)
  (nonce : Nonce)
  (label : String)
  : M Transaction :=
  let
    newResource := mkSpacebuck nonce logic label;
  in mkTransactionNoPublicData@{
       consumed := [newResource@Resource{ephemeral := true}];
       created := [newResource];
     };

ctx : TxContext :=
  TxContext.mk@{
    caller := Universal.identity;
    currentRoot := CommitmentRoot.fromNat 0;
  };

main (logic : Logic) : TransactionRequest :=
  TransactionRequest.build
    0
    ctx
    (spacebuckTransaction logic (Nonce.fromAnomaAtom 0) "Hello World!\n");
