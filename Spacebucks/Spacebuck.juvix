module Spacebucks.Spacebuck;


import Stdlib.Prelude open;
import Applib open;
import Anoma.Encode open;


-- ### Module, imports ###

--- A logic function that is always valid.
logic : Logic := Logic.mk \{_ := true};

mkSpacebuck
  (nonce : Nonce)
  (message : String)
  {ephemeral : Bool := false}
  : Resource :=
  Resource.mk@{
    logic := Encoded.encode logic;
    label := Label.fromNat (builtinAnomaEncode message);
    value := AnomaAtom.fromNat 0;
    quantity := 1;
    ephemeral;
    nonce := Nonce.toRaw nonce;
    nullifierKeyCommitment := AnomaAtom.fromNat 0;
    unusedRandSeed := 0;
  };


spacebuckTransaction
  {M : Type -> Type} -- polymorphic function with type parameter M
  {{Monad M}} -- additional information for type parameter M
  {{Tx M}} -- random number generator needs side effects / Monad
  (nonce : Nonce)
  (label : String)
  : M Transaction :=
  let
  newResource := mkSpacebuck nonce label;
  in
  mkTransactionNoPublicData@{
    consumed := [newResource@Resource{ephemeral := true}];
    created := [newResource]
  };


ctx : TxContext :=
  TxContext.mk@{
    caller := Universal.identity;
    currentRoot := CommitmentRoot.fromNat 0;
  };

main : TransactionRequest :=
  TransactionRequest.build 0 ctx (spacebuckTransaction (Nonce.fromAnomaAtom 0) "Hello World!\n");